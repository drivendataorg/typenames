{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"typenames : String representations of type annotations","text":"<p>typenames is a configurable Python library for creating string representations of type annotations. By default, it produces compact representations by removing standard library module names. Configurable options include standardizing on <code>|</code> operator syntax for unions or standard collections classes for generics.</p> <pre><code>import typing\nfrom typenames import typenames\n\ntypenames(int)\n#&gt; 'int'\ntypenames(dict[str, typing.Any])\n#&gt; 'dict[str, Any]'\ntypenames(str | int)\n#&gt; 'str | int'\ntypenames(typing.Optional[str])\n#&gt; 'Optional[str]'\n</code></pre>"},{"location":"#why-use-this-library","title":"Why use this library?","text":"<p>String representations of Python type objects, type aliases, and special typing forms are inconsistent and often verbose. Here are some comparisons using default settings against built-in string representations:</p> Input With <code>str(...)</code> With <code>typenames(...)</code> <code>int</code> <code>&lt;class 'int'&gt;</code> <code>int</code> <code>list</code> <code>&lt;class 'list'&gt;</code> <code>list</code> <code>typing.Optional[int]</code> <code>typing.Optional[int]</code> <code>Optional[int]</code> <code>collections.abc.Iterator[typing.Any]</code> <code>collections.abc.Iterator[typing.Any]</code> <code>Iterator[Any]</code> <code>typing.Literal[MyEnum.NAME]</code> <code>typing.Literal[&lt;MyEnum.NAME: 'value'&gt;]</code> <code>Literal[MyEnum.NAME]</code> <p>typenames also has handy configurable functionality, such as:</p> <ul> <li>Forcing standardization on <code>|</code> operator union syntax (e.g., <code>Union[int, str]</code> to <code>int | str</code>) or vice versa</li> <li>Forcing standardization on <code>|</code> operator optional syntax (e.g., <code>Optional[int]</code> to <code>int | None</code>) or vice versa</li> <li>Forcing standardization on standard collection types for generics (e.g., <code>List[int]</code> to <code>list[int]</code>) or vice versa</li> <li>Controlling exactly which module names to remove using regex patterns.</li> </ul> <p>No need for string manipulation to get what you want!</p>"},{"location":"#installation","title":"Installation","text":"<p>typenames is available on PyPI:</p> <pre><code>pip install typenames\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>The main way to use the library is the <code>typenames</code> function. Calling it on a type annotation renders a string representation:</p> <pre><code>import typing\nfrom typenames import typenames\n\ntypenames(int)\n#&gt; 'int'\ntypenames(typing.Optional[str])\n#&gt; 'Optional[str]'\ntypenames(collections.abc.Callable[[int], tuple[str, ...]])\n#&gt; 'Callable[[int], tuple[str, ...]]\n</code></pre> <p>Under the hood, typenames parses a type annotation as a tree structure. If you need to see the parsed tree, use the <code>parse_type_tree</code> function to return the root node. You can get the rendered string representation by calling <code>str(...)</code> on root node.</p> <pre><code>import typing\nfrom typenames import parse_type_tree\n\ntree = parse_type_tree(typing.Union[typing.Any, list[typing.Any]])\ntree\n#&gt; &lt;GenericNode typing.Union[&lt;TypeNode typing.Any&gt;, &lt;GenericNode &lt;class 'list'&gt;[&lt;TypeNode typing.Any&gt;]&gt;]&gt;\nstr(tree)\n#&gt; 'Union[Any, list[Any]]'\n</code></pre>"},{"location":"#configurable-options","title":"Configurable options","text":"<p>All configuration options can be passed as keyword arguments to either the <code>typenames</code> or <code>parse_type_tree</code> functions.</p>"},{"location":"#union-syntax-union_syntax","title":"Union Syntax (<code>union_syntax</code>)","text":"<p>This option controls how unions are rendered. It supports both the <code>typing.Union</code> special form and the <code>|</code> operator (bitwise or) syntax from PEP 604. Valid options are defined by the enum <code>UnionSyntax</code> and include:</p> <ul> <li><code>\"as_given\"</code> (default): render the union as it is given without changing syntax.</li> <li><code>\"or_operator\"</code>: render all type unions using the <code>|</code> operator.</li> <li><code>\"special_form\"</code>: render all type unions using the <code>typing.Union</code> special form.</li> </ul> <p>Note that runtime use of the <code>|</code> operator between types is new in Python 3.10. To use in earlier versions of Python, you will need to use postponed evaluation of annotations \u00e0 la PEP 563 with <code>from __future__ import__annotations__</code>. Support for the <code>|</code> operator is only a limitation on providing type annotation inputs to typenames, and not a limitation on output rendering.</p> <p>Limitations: Python automatically flattens unions when evaluating them at runtime. Since typenames uses runtime type objects, it will only see the flattened result and not know if your original input was nested. Furthermore, any mixing of <code>|</code> operator syntax and any typing module types will result in a <code>typing.Union</code> union, so <code>as_given</code> will always render such inputs with <code>typing.Union</code>.</p>"},{"location":"#optional-syntax-optional_syntax","title":"Optional Syntax (<code>optional_syntax</code>)","text":"<p>This option controls how optional types are rendered. It supports both the <code>typing.Optional</code> special form and the <code>|</code> operator (bitwise or) syntax from PEP 604. Valid options are defined by the enum <code>OptionalSyntax</code> and include:</p> <ul> <li><code>\"as_given\"</code> (default): render the optional type as it is given without changing syntax</li> <li><code>\"or_operator\"</code>: render all optional types using the <code>|</code> operator</li> <li><code>\"union_special_form\"</code>: render all optional types using the <code>typing.Optional</code> special form</li> <li><code>\"optional_special_form\"</code>: render all optional types using the <code>typing.Optional</code> special form</li> </ul> <p>Note that runtime use of the <code>|</code> operator between types is new in Python 3.10. To use in earlier versions of Python, you will need to use postponed evaluation of annotations \u00e0 la PEP 563 with <code>from __future__ import__annotations__</code>. Support for the <code>|</code> operator is only a limitation on providing type annotation inputs to typenames, and not a limitation on output rendering.</p> <p>Limitations:</p> <ul> <li>Python automatically converts <code>typing.Union[..., None]</code> to <code>typing.Optional[...]</code> when evaluating at runtime. Since typenames uses runtime type objects, it will only see the result using <code>typing.Optional</code> and not know the form of your original input.</li> <li>Python automatically flattens unions when evaluating them at runtime. Since typenames uses runtime type objects, it will only see the flattened result and not know if your original input was nested. Furthermore, any mixing of <code>|</code> operator syntax and any typing module types will result in a <code>typing.Union</code> union, so <code>as_given</code> will always render such inputs with typing module special forms.</li> <li>The <code>typing.Optional</code> special form only accepts exactly one parameter. By default, typenames will render cases with multiple parameters with <code>Optional[Union[...]]</code>. You can use the <code>union_syntax</code> option to control the inner union's syntax.</li> </ul>"},{"location":"#standard-collection-syntax-standard_collection_syntax","title":"Standard Collection Syntax (<code>standard_collection_syntax</code>)","text":"<p>This option controls how parameterized standard collection generic types are rendered. It supports both the typing module's generic aliases (e.g., <code>typing.List[...]</code>) and the standard class (e.g., <code>list[...]</code>) syntax from PEP 585. Valid options are defined by the enum <code>StandardCollectionSyntax</code> and include:</p> <ul> <li><code>\"as_given\"</code> (default): render the parameterized generic type as it is given without changing syntax</li> <li><code>\"standard_class\"</code>: render all parameterized standard collection generic types using their class</li> <li><code>\"typing_module\"</code>: render all parameterized standard collection generic types using the typing module's generic alias</li> </ul> <p>Note that runtime use of standard collection classes as parameterized generic types is new in Python 3.9. To use in earlier versions of Python, you will need to use postponed evaluation of annotations \u00e0 la PEP 563 with <code>from __future__ import__annotations__</code>. Support for standard collection classes for parameterized generic types is only a limitation on providing type annotation inputs to typenames, and not a limitation on output rendering.</p>"},{"location":"#removing-module-names-remove_modules","title":"Removing Module Names (<code>remove_modules</code>)","text":"<p>This option controls how module names are removed from the rendered output. It takes a list of inputs, which can either be a string of the module name or a <code>re.Pattern</code> regex pattern directly (the result of <code>re.compile</code>). String inputs are templated into the following regex pattern:</p> <pre><code>module: str  # Given module name\nre.compile(r\"^{}\\.\".format(module.replace(\".\", r\"\\.\")))\n</code></pre> <p>Note that module names are removed in the given order, so having entries that are submodules of other entries can potentially lead to the wrong behavior. You can either order them from higher-depth to lower-depth, or directly provide a compiled pattern with optional groups. For example, the pattern <code>re.compile(r\"^collections\\.(abc\\.)?\")</code> will match both <code>\"collections.\"</code> and <code>\"collections.abc.\"</code>.</p> <p>The default list of module names include the standard library modules relevant to PEP 585 plus <code>types</code> and <code>typing</code>. It can be accessed at <code>DEFAULT_REMOVE_MODULES</code>.</p> <pre><code>DEFAULT_REMOVE_MODULES: List[Union[str, re.Pattern]] = [\n    \"__main__\",\n    \"builtins\",\n    re.compile(r\"^collections\\.(abc\\.)?\"),\n    \"contextlib\",\n    \"re\",\n    \"types\",\n    \"typing\",\n]\n</code></pre> <p>If you are trying to add additional modules to this option (rather than overriding the defaults), the easiest way to do so is to concatenate with the default list:</p> <pre><code>from typing import Optional\nfrom typenames import typenames, DEFAULT_REMOVE_MODULES, BaseNode\n\ntypenames(Optional[BaseNode])\n#&gt; 'Optional[typenames.BaseNode]'\ntypenames(Optional[BaseNode], remove_modules=[\"typenames\"])\n#&gt; 'typing.Optional[BaseNode]'\ntypenames(\n    Optional[BaseNode],\n    remove_modules=DEFAULT_REMOVE_MODULES + [\"typenames\"],\n)\n#&gt; 'Optional[BaseNode]'\n</code></pre> <p>To remove all module names, you can use <code>REMOVE_ALL_MODULES</code>, which contains the pattern <code>re.compile(r\"^(&lt;?\\w+&gt;?\\.)+\")</code>.</p> <p><sup>Reproducible examples created by reprexlite.</sup></p>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#typenames-attributes","title":"Attributes","text":""},{"location":"api-reference/#typenames.DEFAULT_REMOVE_MODULES","title":"<code>DEFAULT_REMOVE_MODULES: List[Union[str, re.Pattern]] = ['__main__', 'builtins', re.compile('^collections\\\\.(abc\\\\.)?'), 'contextlib', 're', 'types', 'typing']</code>  <code>module-attribute</code>","text":"<p>List of standard library modules used as the default value for the remove_modules option.</p>"},{"location":"api-reference/#typenames.LITERAL_TYPE_SUPPORTED","title":"<code>LITERAL_TYPE_SUPPORTED = sys.version_info &gt;= (3, 8)</code>  <code>module-attribute</code>","text":"<p>(DEPRECATED) Flag for whether PEP 586's typing.Literal is supported. typenames no longer  supports Python versions where this is false.</p>"},{"location":"api-reference/#typenames.OR_OPERATOR_SUPPORTED","title":"<code>OR_OPERATOR_SUPPORTED = sys.version_info &gt;= (3, 10)</code>  <code>module-attribute</code>","text":"<p>Flag for whether PEP 604's | operator (bitwise or) between types is supported.</p>"},{"location":"api-reference/#typenames.STANDARD_COLLECTION_CLASSES","title":"<code>STANDARD_COLLECTION_CLASSES: typing.FrozenSet[type] = frozenset(STANDARD_COLLECTION_TO_TYPING_ALIAS_MAPPING.keys())</code>  <code>module-attribute</code>","text":"<p>Frozenset of standard collection classes that support use as a generic type starting in Python 3.9 (PEP 585).</p>"},{"location":"api-reference/#typenames.STANDARD_COLLECTION_TO_TYPING_ALIAS_MAPPING","title":"<code>STANDARD_COLLECTION_TO_TYPING_ALIAS_MAPPING: typing.Dict[type, typing._GenericAlias] = {dict: typing.Dict, list: typing.List, set: typing.Set, frozenset: typing.FrozenSet, tuple: typing.Tuple, collections.defaultdict: typing.DefaultDict, collections.OrderedDict: typing.OrderedDict, collections.ChainMap: typing.ChainMap, collections.Counter: typing.Counter, collections.deque: typing.Deque, collections.abc.Awaitable: typing.Awaitable, collections.abc.Coroutine: typing.Coroutine, collections.abc.AsyncIterable: typing.AsyncIterable, collections.abc.AsyncIterator: typing.AsyncIterator, collections.abc.AsyncGenerator: typing.AsyncGenerator, collections.abc.Iterable: typing.Iterable, collections.abc.Iterator: typing.Iterator, collections.abc.Generator: typing.Generator, collections.abc.Reversible: typing.Reversible, collections.abc.Collection: typing.Collection, collections.abc.Container: typing.Container, collections.abc.Callable: typing.Callable, collections.abc.Set: typing.AbstractSet, collections.abc.MutableSet: typing.MutableSet, collections.abc.Mapping: typing.Mapping, collections.abc.MutableMapping: typing.MutableMapping, collections.abc.Sequence: typing.Sequence, collections.abc.MutableSequence: typing.MutableSequence, collections.abc.ByteString: typing.ByteString, collections.abc.MappingView: typing.MappingView, collections.abc.KeysView: typing.KeysView, collections.abc.ItemsView: typing.ItemsView, collections.abc.ValuesView: typing.ValuesView, contextlib.AbstractContextManager: typing.ContextManager, contextlib.AbstractAsyncContextManager: typing.AsyncContextManager, re.Pattern: typing.Pattern, re.Match: typing.Match}</code>  <code>module-attribute</code>","text":"<p>Mapping from standard collection types that support use as a generic type starting in Python 3.9 (PEP 585) to their associated typing module generic alias.</p>"},{"location":"api-reference/#typenames-classes","title":"Classes","text":""},{"location":"api-reference/#typenames.BaseNode","title":"<code>BaseNode</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Abstract base class for a typenames node.</p> Source code in <code>typenames.py</code> <pre><code>@dataclasses.dataclass(repr=False)\nclass BaseNode(abc.ABC, typing.Generic[T]):\n    \"\"\"Abstract base class for a typenames node.\"\"\"\n\n    tp: typing.Type[T]\n    config: TypenamesConfig\n\n    @property\n    @abc.abstractmethod\n    def is_none_type(self) -&gt; bool:\n        \"\"\"Whether this node corresponds to NoneType, which is the type of None. Used to identify\n        the \"Optional\" special case of a union of types.\n\n        Returns:\n            bool: True if this node's tp is NoneType.\n        \"\"\"\n\n    def process_module_prefix(self, module_prefix: str) -&gt; str:\n        \"\"\"Processes a module prefix (including the trailing '.') according to the 'remove_modules'\n        settings in the given configuration.\"\"\"\n        # Remove module names\n        for pattern in self.config.remove_modules_patterns:\n            module_prefix = pattern.sub(\"\", module_prefix)\n        return module_prefix\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{type(self).__name__} {repr(self.tp)}&gt;\"\n</code></pre>"},{"location":"api-reference/#typenames.BaseNode-attributes","title":"Attributes","text":""},{"location":"api-reference/#typenames.BaseNode.is_none_type","title":"<code>is_none_type: bool</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Whether this node corresponds to NoneType, which is the type of None. Used to identify the \"Optional\" special case of a union of types.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this node's tp is NoneType.</p>"},{"location":"api-reference/#typenames.BaseNode-functions","title":"Functions","text":""},{"location":"api-reference/#typenames.BaseNode.process_module_prefix","title":"<code>process_module_prefix(module_prefix: str) -&gt; str</code>","text":"<p>Processes a module prefix (including the trailing '.') according to the 'remove_modules' settings in the given configuration.</p> Source code in <code>typenames.py</code> <pre><code>def process_module_prefix(self, module_prefix: str) -&gt; str:\n    \"\"\"Processes a module prefix (including the trailing '.') according to the 'remove_modules'\n    settings in the given configuration.\"\"\"\n    # Remove module names\n    for pattern in self.config.remove_modules_patterns:\n        module_prefix = pattern.sub(\"\", module_prefix)\n    return module_prefix\n</code></pre>"},{"location":"api-reference/#typenames.GenericNode","title":"<code>GenericNode</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BaseNode</code></p> <p>Node that represents a generic type.</p> Source code in <code>typenames.py</code> <pre><code>@dataclasses.dataclass(repr=False)\nclass GenericNode(BaseNode):\n    \"\"\"Node that represents a generic type.\"\"\"\n\n    origin: Union[Any, None]\n    arg_nodes: List[BaseNode]\n\n    @property\n    def is_none_type(self) -&gt; bool:\n        return False\n\n    def __str__(self) -&gt; str:\n        arg_nodes = list(self.arg_nodes)\n\n        # Case: typing.Union\n        if is_union_special_form(self.tp):\n            # Case: typing.Optional\n            if any(a.is_none_type for a in arg_nodes):\n                if self.config.optional_syntax == OptionalSyntax.OR_OPERATOR:\n                    return \" | \".join(str(a) for a in arg_nodes)\n                elif self.config.optional_syntax == OptionalSyntax.UNION_SPECIAL_FORM:\n                    origin_module_prefix = \"typing.\"\n                    origin_name = \"Union\"\n                else:\n                    origin_module_prefix = \"typing.\"\n                    origin_name = \"Optional\"\n                    arg_nodes = [a for a in arg_nodes if a.tp is not type(None)]\n                    if len(arg_nodes) &gt; 1:\n                        # typing.Optional is only valid for a single parameter,\n                        # need to use a union inside\n                        arg_nodes = [\n                            GenericNode(\n                                tp=typing.Union[  # type: ignore[arg-type]\n                                    tuple(a.tp for a in arg_nodes)\n                                ],\n                                config=self.config,\n                                origin=typing.Union,\n                                arg_nodes=arg_nodes,\n                            )\n                        ]\n\n            # Case: regular Union\n            else:\n                if self.config.union_syntax == UnionSyntax.OR_OPERATOR:\n                    return \" | \".join(str(a) for a in arg_nodes)\n                else:\n                    origin_module_prefix = \"typing.\"\n                    origin_name = \"Union\"\n        # Case: Union with | operator (bitwise or)\n        elif is_union_or_operator(self.tp):\n            is_optional = any(a.is_none_type for a in arg_nodes)\n            # Case: ... | None (optional) and configured to use typing.Optional\n            if is_optional and self.config.optional_syntax == OptionalSyntax.OPTIONAL_SPECIAL_FORM:\n                origin_module_prefix = \"typing.\"\n                origin_name = \"Optional\"\n                arg_nodes = [a for a in arg_nodes if a.tp is not type(None)]\n                if len(arg_nodes) &gt; 1:\n                    # typing.Optional is only valid for a single parameter,\n                    # need to use a union inside\n                    arg_nodes = [\n                        GenericNode(\n                            tp=typing.Union[  # type: ignore[arg-type]\n                                tuple(a.tp for a in arg_nodes)\n                            ],\n                            config=self.config,\n                            origin=typing.Union,\n                            arg_nodes=arg_nodes,\n                        )\n                    ]\n            # Case: ... | None (optional) and configured to use typing.Union\n            elif is_optional and self.config.optional_syntax == OptionalSyntax.UNION_SPECIAL_FORM:\n                origin_module_prefix = \"typing.\"\n                origin_name = \"Union\"\n            # Case: regular union\n            else:\n                if self.config.union_syntax == UnionSyntax.SPECIAL_FORM:\n                    origin_module_prefix = \"typing.\"\n                    origin_name = \"Union\"\n                else:\n                    return \" | \".join(str(a) for a in arg_nodes)\n        # Case: Standard collection class alias\n        elif is_standard_collection_type_alias(self.tp):\n            if self.config.standard_collection_syntax == StandardCollectionSyntax.TYPING_MODULE:\n                typing_alias = STANDARD_COLLECTION_TO_TYPING_ALIAS_MAPPING[\n                    get_origin(self.tp)  # type: ignore\n                ]\n                origin_module_prefix = \"typing.\"\n                origin_name = f\"{typing_alias._name}\"  # type: ignore\n            else:\n                origin_module_prefix = self.origin.__module__ + \".\"\n                origin_name = self.origin.__qualname__  # type: ignore[union-attr]\n        # Case: Typing module collection alias\n        elif is_typing_module_collection_alias(self.tp):\n            if self.config.standard_collection_syntax == StandardCollectionSyntax.STANDARD_CLASS:\n                origin_module_prefix = self.origin.__module__ + \".\"\n                origin_name = self.origin.__qualname__  # type: ignore[union-attr]\n            else:\n                origin_module_prefix = \"typing.\"\n                origin_name = self.tp._name\n        # Case: Some other generic type\n        else:\n            if hasattr(self.origin, \"__module__\"):\n                origin_module_prefix = self.origin.__module__ + \".\"\n            else:\n                origin_module_prefix = \"\"\n            origin_name = getattr(\n                self.origin, \"__name__\", getattr(self.origin, \"_name\", str(self.origin))\n            )\n\n        # Remove module names\n        origin_module_prefix = self.process_module_prefix(origin_module_prefix)\n\n        args_string = \", \".join(str(a) for a in arg_nodes)\n        return f\"{origin_module_prefix}{origin_name}[{args_string}]\"\n\n    def __repr__(self) -&gt; str:\n        args_repr = \", \".join(repr(a) for a in self.arg_nodes)\n        return f\"&lt;{type(self).__name__} {repr(self.origin)}[{args_repr}]&gt;\"\n</code></pre>"},{"location":"api-reference/#typenames.LiteralNode","title":"<code>LiteralNode</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BaseNode</code></p> <p>Node that represents a literal value. Used for the arguments of Literal. Valid types for a literal value include ints, byte strings, unicode strings, bools, Enum values, None.</p> Source code in <code>typenames.py</code> <pre><code>@dataclasses.dataclass(repr=False)\nclass LiteralNode(BaseNode):\n    \"\"\"Node that represents a literal value. Used for the arguments of Literal. Valid types for\n    a literal value include ints, byte strings, unicode strings, bools, Enum values, None.\"\"\"\n\n    @property\n    def is_none_type(self) -&gt; typing.NoReturn:\n        # Don't expect to call this\u2014only used for checking args of union\n        raise NotImplementedError(  # pragma: no cover\n            \"LiteralNode.is_none_type should not be called.\"\n        )\n\n    def __str__(self) -&gt; str:\n        if isinstance(self.tp, Enum):\n            return f\"{self.tp.__class__.__name__}.{self.tp.name}\"\n        else:\n            return repr(self.tp)\n</code></pre>"},{"location":"api-reference/#typenames.OptionalSyntax","title":"<code>OptionalSyntax</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for optional syntax options. See \"Optional Syntax\" section of README for documentation.</p> Source code in <code>typenames.py</code> <pre><code>class OptionalSyntax(str, Enum):\n    \"\"\"Enum for optional syntax options. See \"Optional Syntax\" section of README for\n    documentation.\"\"\"\n\n    AS_GIVEN = \"as_given\"\n    OR_OPERATOR = \"or_operator\"\n    OPTIONAL_SPECIAL_FORM = \"optional_special_form\"\n    UNION_SPECIAL_FORM = \"union_special_form\"\n</code></pre>"},{"location":"api-reference/#typenames.ParamsListNode","title":"<code>ParamsListNode</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BaseNode</code></p> <p>Node that represents a list of parameters. Used for the arguments of Callable.</p> Source code in <code>typenames.py</code> <pre><code>@dataclasses.dataclass(repr=False)\nclass ParamsListNode(BaseNode):\n    \"\"\"Node that represents a list of parameters. Used for the arguments of Callable.\"\"\"\n\n    arg_nodes: List[BaseNode]\n\n    @property\n    def is_none_type(self) -&gt; typing.NoReturn:\n        # Don't expect to call this\u2014only used for checking args of union\n        raise NotImplementedError(  # pragma: no cover\n            \"ParamsListNode.is_none_type should not be called.\"\n        )\n\n    def __str__(self) -&gt; str:\n        args_string = \", \".join(str(a) for a in self.arg_nodes)\n        return f\"[{args_string}]\"\n</code></pre>"},{"location":"api-reference/#typenames.StandardCollectionSyntax","title":"<code>StandardCollectionSyntax</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for standard collection parameterized generic options. See \"Standard Collection Syntax\" section of README for documentation.</p> Source code in <code>typenames.py</code> <pre><code>class StandardCollectionSyntax(str, Enum):\n    \"\"\"Enum for standard collection parameterized generic options. See \"Standard Collection Syntax\"\n    section of README for documentation.\"\"\"\n\n    AS_GIVEN = \"as_given\"\n    STANDARD_CLASS = \"standard_class\"\n    TYPING_MODULE = \"typing_module\"\n</code></pre>"},{"location":"api-reference/#typenames.TypeNode","title":"<code>TypeNode</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BaseNode</code></p> <p>Node that represents a singleton type.</p> Source code in <code>typenames.py</code> <pre><code>@dataclasses.dataclass(repr=False)\nclass TypeNode(BaseNode):\n    \"\"\"Node that represents a singleton type.\"\"\"\n\n    @property\n    def is_none_type(self) -&gt; bool:\n        return self.tp is type(None)\n\n    def __str__(self) -&gt; str:\n        if hasattr(self.tp, \"__module__\"):\n            module_prefix = getattr(self.tp, \"__module__\") + \".\"\n        else:\n            module_prefix = \"\"\n\n        if self.tp is Ellipsis:\n            type_name = \"...\"\n        elif self.tp is type(None):\n            type_name = \"None\"\n        elif self.tp is typing.Any:\n            type_name = \"Any\"\n        elif isinstance(self.tp, typing.ForwardRef):\n            forward_arg = self.tp.__forward_arg__\n            # Assume if there is dotted path, then it is a module path\n            if \".\" in forward_arg:\n                module, dot, type_name = forward_arg.rpartition(\".\")\n                module_prefix = module + dot\n            else:\n                type_name = forward_arg\n        else:\n            type_name = getattr(self.tp, \"__qualname__\", repr(self.tp))\n        for pattern in self.config.remove_modules_patterns:\n            type_name = pattern.sub(\"\", type_name)\n        # Remove module names\n        module_prefix = self.process_module_prefix(module_prefix)\n\n        return module_prefix + type_name\n</code></pre>"},{"location":"api-reference/#typenames.TypenamesConfig","title":"<code>TypenamesConfig</code>  <code>dataclass</code>","text":"<p>Dataclass that holds all configuration options. See \"Configurable options\" section of README for documentation.</p> Source code in <code>typenames.py</code> <pre><code>@dataclasses.dataclass\nclass TypenamesConfig:\n    \"\"\"Dataclass that holds all configuration options. See \"Configurable options\" section of README\n    for documentation.\"\"\"\n\n    union_syntax: UnionSyntax = UnionSyntax.AS_GIVEN\n    optional_syntax: OptionalSyntax = OptionalSyntax.AS_GIVEN\n    standard_collection_syntax: StandardCollectionSyntax = StandardCollectionSyntax.AS_GIVEN\n    remove_modules: List[Union[str, re.Pattern]] = dataclasses.field(\n        default_factory=lambda: list(DEFAULT_REMOVE_MODULES)\n    )\n\n    def __post_init__(self):\n        self.union_syntax = UnionSyntax(self.union_syntax)\n        self.optional_syntax = OptionalSyntax(self.optional_syntax)\n        self.standard_collection_syntax = StandardCollectionSyntax(self.standard_collection_syntax)\n\n    @property\n    def remove_modules_patterns(self) -&gt; typing.Iterator[re.Pattern]:\n        \"\"\"Generator that yields remove_modules configuration values as compiled regex\n        patterns.\"\"\"\n        for module in self.remove_modules:\n            if isinstance(module, re.Pattern):\n                yield module\n            else:\n                yield re.compile(r\"^{}\\.\".format(module.replace(\".\", r\"\\.\")))\n</code></pre>"},{"location":"api-reference/#typenames.TypenamesConfig-attributes","title":"Attributes","text":""},{"location":"api-reference/#typenames.TypenamesConfig.remove_modules_patterns","title":"<code>remove_modules_patterns: typing.Iterator[re.Pattern]</code>  <code>property</code>","text":"<p>Generator that yields remove_modules configuration values as compiled regex patterns.</p>"},{"location":"api-reference/#typenames.UnionSyntax","title":"<code>UnionSyntax</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for union syntax options. See \"Union Syntax\" section of README for documentation.</p> Source code in <code>typenames.py</code> <pre><code>class UnionSyntax(str, Enum):\n    \"\"\"Enum for union syntax options. See \"Union Syntax\" section of README for documentation.\"\"\"\n\n    AS_GIVEN = \"as_given\"\n    OR_OPERATOR = \"or_operator\"\n    SPECIAL_FORM = \"special_form\"\n</code></pre>"},{"location":"api-reference/#typenames-functions","title":"Functions","text":""},{"location":"api-reference/#typenames.is_standard_collection_type_alias","title":"<code>is_standard_collection_type_alias(tp: type) -&gt; bool</code>","text":"<p>Check if type annotation is a generic type and uses a standard collection type as a generic alias.</p> Source code in <code>typenames.py</code> <pre><code>def is_standard_collection_type_alias(tp: type) -&gt; bool:\n    \"\"\"Check if type annotation is a generic type and uses a standard collection type as a generic\n    alias.\"\"\"\n    return (\n        get_origin(tp) in STANDARD_COLLECTION_CLASSES\n        and type(tp) is not typing._GenericAlias  # type: ignore[attr-defined]\n    )\n</code></pre>"},{"location":"api-reference/#typenames.is_typing_module_collection_alias","title":"<code>is_typing_module_collection_alias(tp: type) -&gt; bool</code>","text":"<p>Check if type annotation is a generic type and uses a typing module collection generic alias, e.g., typing.List.</p> Source code in <code>typenames.py</code> <pre><code>def is_typing_module_collection_alias(tp: type) -&gt; bool:\n    \"\"\"Check if type annotation is a generic type and uses a typing module collection generic\n    alias, e.g., typing.List.\"\"\"\n    return (\n        get_origin(tp) in STANDARD_COLLECTION_CLASSES\n        and type(tp) is typing._GenericAlias  # type: ignore[attr-defined]\n    )\n</code></pre>"},{"location":"api-reference/#typenames.is_union_or_operator","title":"<code>is_union_or_operator(tp: type) -&gt; bool</code>","text":"<p>Check if type annotation is a union and uses | operator (bitwise or).</p> Source code in <code>typenames.py</code> <pre><code>def is_union_or_operator(tp: type) -&gt; bool:\n    \"\"\"Check if type annotation is a union and uses | operator (bitwise or).\"\"\"\n    return OR_OPERATOR_SUPPORTED and isinstance(tp, types.UnionType)\n</code></pre>"},{"location":"api-reference/#typenames.is_union_special_form","title":"<code>is_union_special_form(tp: type) -&gt; bool</code>","text":"<p>Check if type annotation is a union and uses the typing.Union special form.</p> Source code in <code>typenames.py</code> <pre><code>def is_union_special_form(tp: type) -&gt; bool:\n    \"\"\"Check if type annotation is a union and uses the typing.Union special form.\"\"\"\n    return get_origin(tp) is typing.Union\n</code></pre>"},{"location":"api-reference/#typenames.parse_type_tree","title":"<code>parse_type_tree(tp: type, config: Optional[TypenamesConfig] = None, **kwargs: Any) -&gt; BaseNode</code>","text":"<p>Parses a given type annotation into a tree data structure.</p> <p>Parameters:</p> Name Type Description Default <code>tp</code> <code>type</code> <p>Type annotation</p> required <code>config</code> <code>Optional[TypenamesConfig]</code> <p>Configuration dataclass. Defaults to None, which will instantiate one with default values.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Override configuration options on provided or default configuration. See \"Configurable options\" section of README for documentation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>BaseNode</code> <code>BaseNode</code> <p>Root node of parsed type tree</p> Source code in <code>typenames.py</code> <pre><code>def parse_type_tree(tp: type, config: Optional[TypenamesConfig] = None, **kwargs: Any) -&gt; BaseNode:\n    \"\"\"Parses a given type annotation into a tree data structure.\n\n    Args:\n        tp (type): Type annotation\n        config (Optional[TypenamesConfig]): Configuration dataclass. Defaults to None, which will\n            instantiate one with default values.\n        **kwargs: Override configuration options on provided or default configuration. See\n            \"Configurable options\" section of README for documentation.\n\n    Returns:\n        BaseNode: Root node of parsed type tree\n    \"\"\"\n    if config is None:\n        config = TypenamesConfig(**kwargs)\n    else:\n        config = dataclasses.replace(config, **kwargs)\n\n    node: BaseNode\n    origin = get_origin(tp)\n    if origin:\n        args = get_args(tp)\n        node = GenericNode(\n            tp=tp,\n            origin=origin,\n            arg_nodes=[parse_type_tree(a, config=config) for a in args],\n            config=config,\n        )\n    elif isinstance(tp, list):\n        # This is the parameter list for Callable\n        node = ParamsListNode(tp=tp, arg_nodes=[parse_type_tree(a) for a in tp], config=config)\n    elif isinstance(tp, (int, bytes, str, Enum, bool)) or tp is None:\n        node = LiteralNode(tp=tp, config=config)\n    else:\n        node = TypeNode(tp=tp, config=config)\n    return node\n</code></pre>"},{"location":"api-reference/#typenames.typenames","title":"<code>typenames(tp: type, config: Optional[TypenamesConfig] = None, **kwargs: Any) -&gt; str</code>","text":"<p>Render a string representation of a type annotation.</p> <p>Parameters:</p> Name Type Description Default <code>tp</code> <code>type</code> <p>Type annotation.</p> required <code>config</code> <code>Optional[TypenamesConfig]</code> <p>Configuration dataclass. Defaults to None, which will instantiate one with default values.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Override configuration options on provided or default configuration. See \"Configurable options\" section of README for documentation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of input type.</p> Source code in <code>typenames.py</code> <pre><code>def typenames(tp: type, config: Optional[TypenamesConfig] = None, **kwargs: Any) -&gt; str:\n    \"\"\"Render a string representation of a type annotation.\n\n    Args:\n        tp (type): Type annotation.\n        config (Optional[TypenamesConfig]): Configuration dataclass. Defaults to None, which will\n            instantiate one with default values.\n        **kwargs: Override configuration options on provided or default configuration. See\n            \"Configurable options\" section of README for documentation.\n\n    Returns:\n        str: String representation of input type.\n    \"\"\"\n    tree = parse_type_tree(tp=tp, config=config, **kwargs)\n    return str(tree)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v110-2024-03-08","title":"v1.1.0 (2024-03-08)","text":"<ul> <li>Changed <code>REMOVE_ALL_MODULES</code>'s regex pattern to also remove <code>&lt;locals&gt;</code> from rendered output. <code>&lt;locals&gt;</code> typically appears in a type's qualified name if the type was defined within the local scope of a function or class method. (PR #4)</li> <li>Removed support for Python 3.7. (PR #5)</li> <li>Deprecated <code>LITERAL_TYPE_SUPPORTED</code> flag, since typenames no longer supports Python versions where this is false. (PR #5)</li> </ul>"},{"location":"changelog/#v100-2023-02-20","title":"v1.0.0 (2023-02-20)","text":"<p>Initial release! \ud83c\udf89</p>"}]}